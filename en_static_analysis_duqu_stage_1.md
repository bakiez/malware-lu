# A little static analysis #


## Introduction ##

This paper presents an analysis of a Duqu binary where; the keylogger. We focus here on the first stage which decrypts and starts the payload. A second paper shall follows for the remaining payload [stage\_2](en_static_analysis_duqu_stage_2.md).

The goal is not to propose yet another analysis of this malware: others have done much better in a much more complete manner. And since we lack most of the binaries and the data of the case.
The aim is rather to present some static analysis techniques regularly used in response to incidents.

## Toolkit ##
  * [Http://code.google.com/p/metasm/ Metasm] mainly used in [ripper.rb ](http://code.google.com/p/malware-lu/source/browse/duqu/ripper.rb).
  * [Http://www.hex-rays.com/products/ida/support/download\_freeware.shtml IDA 5.0 free] The idb file of analyzed are provided ([read/source/browse/duqu/duqu.idb duqu.idb](http://code.google.com/p/malware-) and [duqu.0x5098.idb](http://code.google.com/p/malware-lu/source/browse/duqu/duqu.0x5098.idb) ). By convention, we name the functions by their virtual address followed in parentheses by the name given in the idb. Example: DEADBEEFh (viandemorte).


## Case Study ##

This document provides an analysis of a sample obtained on [Offensive Computing](http://www.offensivecomputing.net/). The sample is also included in the repository: [9749d38ae9b9ddd81b50aad679ee87ec.zip](http://www.malware.lu/_download.php?md5=9749d38ae9b9ddd81b50aad679ee87ec) (password: infected).
```
$ md5sum duqu
9749d38ae9b9ddd81b50aad679ee87ec duqu
$ Objdump-p where you can admire | head-n 9

duqu: file format pei-i386

Characteristics 0x102
executable
32 bit words

Time / Date Wed Jun 1 4:25:18 2011
Magic 010b (PE32)
```

# Initialization #

The initialisation code is not very interesting:
  * 4013AEh (ParseArgs): parse the command line
    * Verbosity.
    * Action (/ delme / quit / restart).
> > > File names can be provided for input / output. The default values ​​are as follows.
    * The .rsrc for entry cf 401508h (LoadInput)
    * Temporary file for output cf 4010BCh (loadoutput).
  * 401160h (setupIO) built an array of strings (table offset / length + section data) containing the names of the input, output of the current module.
  * Call 401269h (main) where:
    * 4015B5h (LoadResource) recovers in a ressoure. rsrc,
    * 4012BBh (hand) goes into this resource access PAGE\_WRITECOPY.
    * Call 401676h (`main_0`) with arguments
      * arg\_0 (wkmem): the address of the resource + 4kB.
      * arg\_4 (wkmemsize): the size of the resource - 4kB.
      * arg\_8 (action): action parsed.
      * arg\_C (IOdesc): description of IO.
      * arg\_10 (ARGCOUNT): the number of arguments parsed from the command line.
      * arg\_14 (handle\_out): a pointer to a handle that will be closed if returning from the call.
      * arg\_18 (defaultexe): the string "winlogon.exe", noted échou hand if you remember with the "svchost.exe".

The only interesting feature is 4010BCh (loadoutput), it shows the prefix for temporary file: _~DQ_. This could be the reason for the name duqu…

Obfuscation = API call =

Once in 401676h (`main_0`), the first step is to select the path of an executable based on processes in memory, this is done in 4024C0h (selectexe). Then 401B16h (`main_2`) is called with the same arguments as main\_0 where arg\_18 (defaultexe) was substituted by the previously chosen path.

All this initialisation code is quite boring. One aspect is more interesting: the API call in obfucation in 4023F8h (lookforaproc). It in a variant of getfunctionbyname but a hash is provided instead of usual name of the requested API.
  * 401B96h (unxor) xor chain to get the name of the library.
  * 401BCEh (`getfunbyhash_0`) hash all API names one after the other until match with the provided hash. Finally the API address is provided.

As I am very lazy, I won't try to understand this algorithm in detail. I'll just rip the code from the sample and let it do the job.
For this I use [Metasm](http://code.google.com/p/metasm/). The magic is done by [ripper.rb](http://code.google.com/p/malware-lu/source/browse/duqu/ripper.rb) to disassemble the code, encapsulate it in a C function and execute.

## Decryption of strings ##

Lets decriypt the lybrary names. I take the opportunity to decipher all other encryted strings found in the bin.
```
malware-lu $ cat decryptstrings.rb
# include the magic ripper
require "ripper.rb"
# get a disassembler on first arg
disasm = AutoExe.decode_file(ARGV[0]).init_disassembler
# Rip function at 0x401B96 with signature int decrypt(char* in, char* in);
specs = [Spec.new(0x401B96, "int decrypt(char* in, char* out);")]
worker = Ripper.new(disasm, specs)
# For all the encrypted strings offset
for a in [0x384C, 0x3870, 0x388C, 0x38A0, 0x38C0, 0x38D0, 0x3914, 0x3930, 0x39A0, 0x3A10, 0x3A80, 0x3AF0, 0x3B60, 0x3BD0, 0x3C20, 0x3C70, 0x3C88, 0x3DA0, 0x3DD0, 0x3E00, 0x3E60, 0x3E88, 0x3EB0, 0x3EE8, 0x3F10, 0x3F64, 0x3F8C, 0x3FC4, 0x3FD8, 0x4058, 0x4098, 0x40B0, 0x4108, 0x4130, 0x4158, 0x4170, 0x41EC, 0x4200, 0x4230, 0x4270, 0x42B8, 0x42FC, 0x4310, 0x4350, 0x4398, 0x43F4, 0x44FC, 0x4508, 0x4524]
  # Read the encrypted string
  srcFile = File.open(ARGV[0], 'r')
  srcFile.seek(a, IO::SEEK_SET)
  # never longer than 0x80
  src = srcFile.sysread(0x80)
  # Allocate output
  dst = "\x00" * (src.length)
  # Decryt and output
  worker.runner.decrypt(src, dst)
  puts "#{a.to_s(16)}: #{dst}"
end
malware-lu $ ruby decryptstrings.rb duqu
384c: ResumeThread
3870: kernel32.dll
388c: ntdll.dll
38a0: advapi32.dll
38c0: 
38d0: %A\Kaspersky Lab\AVP%v\Bases\*.*c
3914: Mcshield.exe
3930: SOFTWARE\KasperskyLab\protected\AVP80\environment
39a0: SOFTWARE\KasperskyLab\protected\AVP11\environment
3a10: SOFTWARE\KasperskyLab\protected\AVP10\environment
3a80: SOFTWARE\KasperskyLab\protected\AVP9\environment
3af0: SOFTWARE\KasperskyLab\protected\AVP8\environment
3b60: SOFTWARE\KasperskyLab\protected\AVP7\environment
3bd0: SOFTWARE\kasperskylab\avp7\environment
3c20: SOFTWARE\kasperskylab\avp6\environment
3c70: ProductRoot
3c88: avp.exe
3da0: %C\McAfee\Engine\*.dat
3dd0: SOFTWARE\McAfee\VSCore
3e00: szInstallDir32
3e60: avguard.exe
3e88: bdagent.exe
3eb0: UmxCfg.exe
3ee8: fsdfwd.exe
3f10: %C\Symantec Shared\VirusDefs\binhub\*.dat
3f64: rtvscan.exe
3f8c: ccSvcHst.exe
3fc4: ekrn.exe
3fd8: %A\ESET\ESET Smart Security\Updfiles\*.nup
4058: SOFTWARE\TrendMicro\NSC\TmProxy
4098: InstallPath
40b0: tmproxy.exe
4108: SOFTWARE\Rising\RIS
4130: SOFTWARE\Rising\RAV
4158: InstallPath
4170: RavMonD.exe
41ec: 360rp.exe
4200: 360sd.exe
4230: %SystemRoot%\system32\lsass.exe
4270: %SystemRoot%\system32\winlogon.exe
42b8: %SystemRoot%\system32\svchost.exe
42fc: psapi.dll
4310: %SystemRoot%\syswow64\lsass.exe
4350: %SystemRoot%\syswow64\winlogon.exee
4398: %SystemRoot%\syswow64\svchost.exe
43f4: version.dll
44fc: CODE
4508: advapi32.dll
4524: userenv.dll
```


## API calls ##

As this is not a tutorial on PE, I refer to for the difference between file and memory images [loading PE](http://msdn.microsoft.com/en-us/magazine/cc301805.aspx). Let's map with [pedump](http://code.google.com/p/malware-lu/source/browse/duqu/#git%2Fpedump).
```
malware-lu $ cd pedump/
pedump $ make
gcc -o pedump pedump.c pefile.c -I.
pedump $ cd ..
malware-lu $ echo Please get those dll: $(ls *dll)
Please get those dll: advapi32.dll kernel32.dll ntdll.dll psapi.dll userenv.dll version.dll
malware-lu $ for i in $(ls *dll); do pedump/pedump $i > $i.mapped; done
```

For code rippinq we do the same as previously for the strings.
```
malware-lu $ cat getfunbyhash.rb 
# include the magic ripper
require "ripper.rb"
# get a disassembler on first arg
disasm = AutoExe.decode_file(ARGV[0]).init_disassembler
# Rip function at 0x401BCE with signature int decrypt(char* in, char* in);
specs = [Spec.new(0x401BCE,"unsigned int getfun(char* in, unsigned int hash);")]
worker = Ripper.new(disasm, specs)
# Decode exports
pe = Metasm::PE.decode_file_header(ARGV[1])
pe.decode_exports
# for each provided hash
for hash in ARGV[3..ARGV.length]
  # Get the mapped dll
  srcFile = File.open(ARGV[2], 'r')
  src = srcFile.read()
  # Get the rva from duqu code
  rva = worker.runner.getfun(worker.runner.str_ptr(src), hash.hex) - worker.runner.str_ptr(src)
  # Search for the name in exports 
  pe.export.exports.each { |exp|
    if exp.target_rva == rva
      puts "#{hash}:#{exp.name}"
    end
  }
end
malware-lu $ cat export.sh 
#kernel32.dll
echo kernel32.dll
ruby getfunbyhash.rb duqu kernel32.dll kernel32.dll.mapped 0x88444BE9 0x92D66FBA 0xD1A588DB 0xFCAA0AB8 0xAE75A8DB 0xCF5350C5 0xDCAA4C9F 0x4BBFABB8 0xA668559E 0x4761BB27 0xD3E360E9 0x6B3749B3 0xD830E518 0x78C93963 0xD83E926D 0x19BD1298 0x6F8A172D 0xBF464446 0xAE16A0D4 0x3242AC18 0x479DE84E 0xB67F8157
#psapi.dll
echo psapi.dll
ruby getfunbyhash.rb duqu psapi.dll psapi.dll.mapped 0xBCC7C0DA 
#advapi32.dll
echo advapi32.dll
ruby getfunbyhash.rb duqu advapi32.dll advapi32.dll.mapped 0x6012A950 0xC6151DC4 0xF03A2554 0x9C6E14F8 0x702B6244 0x2EDB7947 0x557DBBB6 0xE763A4A3
#version.dll
echo version.dll
ruby getfunbyhash.rb duqu version.dll version.dll.mapped 0xD4DE04DA 0xCEF01246
#userenv.dll
echo userenv.dll
ruby getfunbyhash.rb duqu userenv.dll userenv.dll.mapped 0x3E692063 0xAFF5F91F
#ntdll.dll
echo ntdll.dll
ruby getfunbyhash.rb duqu ntdll.dll ntdll.dll.mapped 0x40C4EC59 0x4FE2B7A2  0x5FC5AD65 0x1D127D2F 0x468B8A32 0xDB8CE88C 0x4143C970
```

Here follows the hash table of the API names.
```
malware-lu $ bash export.sh
kernel32.dll
0x88444BE9:CreateToolhelp32Snapshot
0x92D66FBA:Process32FirstW
0xD1A588DB:Process32NextW
0xFCAA0AB8:OpenProcess
0xAE75A8DB:CreateProcessW
0xCF5350C5:GetNativeSystemInfo
0xDCAA4C9F:IsWow64Process
0x4BBFABB8:lstrcmpiW
0xA668559E:VirtualQuery
0x4761BB27:VirtualProtect
0xD3E360E9:GetProcAddress
0x6B3749B3:MapViewOfFile
0xD830E518:UnmapViewOfFile
0x78C93963:FlushInstructionCache
0xD83E926D:LoadLibraryW
0x19BD1298:FreeLibrary
0x6F8A172D:CreateThread
0xBF464446:WaitForSingleObject
0xAE16A0D4:GetExitCodeThread
0x3242AC18:GetSystemDirectoryW
0x479DE84E:CreateFileW
0xB67F8157:CreateRemoteThread
psapi.dll
0xBCC7C0DA:GetModuleFileNameExW
advapi32.dll
0x6012A950:RegOpenKeyExW
0xC6151DC4:RegQueryValueExW
0xF03A2554:RegCloseKey
0x9C6E14F8:CreateProcessAsUserW
0x702B6244:DuplicateTokenEx
0x2EDB7947:OpenProcessToken
0x557DBBB6:LookupPrivilegeValueW
0xE763A4A3:AdjustTokenPrivileges
version.dll
0xD4DE04DA:GetFileVersionInfoW
0xCEF01246:VerQueryValueW
userenv.dll
0x3E692063:CreateEnvironmentBlock
0xAFF5F91F:DestroyEnvironmentBlock
ntdll.dll
0x40C4EC59:NtQueryInformationProcess
0x40C4EC59:ZwQueryInformationProcess
0x5FC5AD65:NtCreateSection
0x5FC5AD65:ZwCreateSection
0x1D127D2F:NtMapViewOfSection
0x1D127D2F:ZwMapViewOfSection
0x468B8A32:NtUnmapViewOfSection
0x468B8A32:ZwUnmapViewOfSection
0xDB8CE88C:NtClose
0xDB8CE88C:ZwClose
```

# Select the target #

We continue on the reverse of 4024C0h (selectexe).
  * 40F3F8h (lookforaproc) is a simple map of 402397h (gettargetparam) on all process. The loop breaks if 402397h (gettargetparam) is successful.
  * 402397h (gettargetpath) checks whether the name of the process is in the table 40703Ch (proctable), if so 4022E2h (getPath) is applyed. The target process names are the followings:
    * Avp.exe (Kaspersky)
    * Mcshield.exe (McAfee)
    * Avguard.exe (Avira)
    * Bdagent.exe (BitDefender)
    * UmxCfg.exe (CA eTrust)
    * Fsdfwd.exe (Fsecure)
    * Rtvscan.exe (Symantec)
    * CcSvcHst.exe (Symantec)
    * Ekrn.exe (ESET)
    * Tmproxy.exe (PC-cillin)
    * RavMonD.exe (Rising Antivirus)

> 40703Ch (proctable) is a table of the following structure (we take care to define it in ida):
```
00000000 regspec         struc ; (sizeof=0x14)
00000000 key             dd ?
00000004 subkey          dd ?
00000008 value_path      dd ?
0000000C field_C         dd ?
00000010 dfltregkey      dd ?
00000014 regspec         ends
```
  * 4022E2h (getPath) selects a path obtained from the registry key selected according to the file version associated with the targeted proccess.
    * 402242h (regkeywrtprodvs)
      * 4020EBh (getproductversion) opens the targeted process and recovers the associated file name.
      * If OpenProcess fails then 401F7Dh (getpathviacomm) tries to do the same via a COM interface. Once the path is obtained, dwProductVersionLS via GetFileVersionInfoW and VerQueryValueW are saved.

  * proctable\_entry.dwProductVersionLS points to an array of versions. The code loops until a matching version is found. On success, an array of registry key specified by the following structure is retrived.
```
00000000 regspec         struc ; (sizeof=0x14)
00000000 key             dd ?
00000004 subkey          dd ?
00000008 value_path      dd ?
0000000C field_C         dd ?
00000010 dfltregkey      dd ?
00000014 regspec         ends
```
  * I confess to being skeptical about the offsets 0xC and 0x10. Well, who cares?
  * 402079h (GetPathFromReg) loops over the array of registry keys applying 401D5Ch (getvalue) to verify that the recovered path points to an existing file.
  * If 40F3F8h (lookforaproc) does not find a valid path path then a default path is selected based on the return code from one of the tables 407068h (winprocpathtable\_0) (lsass authorized) or 407080h (winprocpathtable) (lsass not authorized). Default path are:
    * %SystemRoot%\system32\lsass.exe
    * %SystemRoot%\system32\winlogon
    * %SystemRoot%\system32\svchost

TRANSLATION TO BE CONTINUED

  * Call 401B16h (hand `_` a) that calls 4019DFh (hand `_` 2) with two arguments.
    * Arg\_0 (exedesc): The following structure
```
00000000 exedesc structure; (sizeof = 0x30)
00000000 targetpath dd?
00000004 machinetype dd?
00000008 wkmem dd?
Nargs 0000000C dd?
00000010 field_10 dd?
00000014 wkmemsize dd?
00000018 Action dd?
0000001C IOdesc dd?
00000020 field_20 dd?
00000024 token dd?
00000028 field_28 dd?
0000002c STARTUPINFO dd?
00000030 exedesc ends
```
    * Arg\_4 (processinfohdl): A pointer to point to the handle of a LPPROCESS\_INFORMATION.

# Decryption stage 2 #

4019DFh (hand `_` 2) begins an internship in deciphering the 4033C4h (decryptstage2). It calls 403315h (getmachine) that recovers the executable _machine type_ targeted earlier in 401B16h (`_` a hand). We then have two cases:
  1. Ch  (i `[` 345 `]` 86): **4035F0h (getstage2) takes stage 2 encrypted address 407098h (stage2) is at offset 0x5098 in the file. The length of the course is 2 bytes of 310hp.
> 8664h****(amd64):** The code calls 4035F0h (pass), an empty function that returns a NULL. Apparently 64bit support is planned but not implemented or stripped.

Both branches lead to 403268h decryption (decrypt). It calculates a name of a mutex since the PID and takes it. This behavior is very strange because the code is not multithreaded. This code should be generic and can be also used in other components where you can admire.
```
todecrypt char * / / = 407098h (stage2) in our case
char name [0x3C];
int i = 0;
GetCurrentProcessId int pid = () ^ todecrypt;
for (; pid! = 0 pid / = 11)
    name [2 * (i + +)] = (pid & 7) + '0 ';
name [2 * i] = 0;
```

Then if test test 407098h (stage2) is encrypted by comparing the first two bytes with "MZ". 40350Eh (decrypt `_` 0) takes care of decryption: xor on a kind of seed. Again we are lazy so we do not care about the exact algorithm. As before, we'll rip 40350Eh (decrypt `_` 0) to get the stage 2 in the clear.
```
$ Cat decryptstage2.rb
# Include the magic ripper
require "ripper.rb"
# Get a disassembler on first arq
disasm AutoExe.decode_file = (ARGV [0]). init_disassembler
# Rip with signing function at 0x40350E int decrypt (char * text, int length, int * key);
specs = [Spec.new (0x40350E, "int decrypt (char * text, int length, int * key);")]
Actually # rip it
worker = Ripper.new (disasm, specs)
# Setup the argument is the file offset 0x5098 Corresponding to 407098h
length = 0x310C
offset = 0x5098
srcfile = File.open (ARGV [0], 'r')
srcFile.seek (offset, IO :: SEEK_SET)
src = srcFile.sysread (length)
a = "\ x00" * 4
# Launch the ripped function
worker.runner.decrypt (src, length, a)
# Output text in clear
File.open (ARGV [0] + "# {offset.to_s .0 x (16)}. Decrypted ',' w + ') {| fd | fd << src}
$ Ruby decryptstage2.rb where you can admire
$ File duqu.0x5098.decrypted
duqu.0x5098.decrypted: PE32 executable for MS Windows (GUI) Intel 80386 32-bit
```

After releasing the mutex you're done with the decryption stage 2 is returned in 4019DFh (hand `_` 2).

Launch of internship = 2 =

Once stage 2 is decrypted, 4019DFh (hand `_` 2) calls 40266Fh (checkPE) which verifies that decryption went fine by checking the headers "MZ", "EP" and the size of the optional header. Note1: stage 2 is a PE. Note2: Both 32bit and 64bit are accepted. 40266Fh (checkPE) also makes a pointer to the PE header of stage 2.

This is followed by the creation of a very daunting 402F82h console with (`_` createconsole 0). In outline:
  * Simple version: it has not provided a token and called 402DF0h (do\_CreateProcess) makes us a simple CreateProcess (CREATE\_NO\_WINDOW | CREATE\_UNICODE\_ENVIRONMENT | CREATE\_SUSPENDED | DETACHED\_PROCESS) | CREATE\_NEW\_CONSOLE, creating console is passed as an argument: arg\_10 (createconsole).
  * Long version: it was a token for the new process
    * Adjust the token privilege Current (SeTcbPrivilege, SeAssignPrimaryTokenPrivilege. SeIncreaseQuotaPrivilege, SeImpersonatePrivilege).
    * Duplication of the token.
    * Get environment variable to the target user.
    * Creation Process (CREATE\_NO\_WINDOW | CREATE\_UNICODE\_ENVIRONMENT | CREATE\_SUSPENDED | DETACHED\_PROCESS) | CREATE\_NEW\_CONSOLE, creating console is passed as an argument: arg\_10 (createconsole).
    * We nétoie the environment and the copy of the token.

Back in 4019DFh (hand `_` 2):
  * 401A54h, it retrieves a pointer to the PE header of the resource wkmem exedesc. Note: This resource was therefore a PE ... we had not bothered to look.
  * 401A6Eh, we verify that the target of the injection well is a 32 bit process.
  * 401A6Eh, we verify that the target process and wkmem have the same machine type.
  * 402E99h (getprocinfo) recovers from arg\_4 (procinfohdl) of 4019DFh (hand `_` 2)
    * Basic process information,
    * InheritedAddressSpace
    * Entrypoint
  * 401AB3h (maprocmem) wkmem load into memory.
  * 4025C0h (UnmapViewOfSection) is just a wrapper to UnmapViewOfSection, here we nétoie the view of the target process mapped into UnmapViewOfSection.
  * 40189Ah (mapstage2\_1) ​​load stage 2 copy in memory and resources.
  * We run the course through a ResumeThread. This API call and offended in a manner somewhat different. It makes use toujour 401BCEh (getfunbyhash\_0) but here the hash is calculated from the chain 40534C (ResumeThread). The code [decode.401D18.c](http://code.google.com/p/malware-lu/source/browse/duqu/decode.401D18.c) calculates the hash.
```
# Include <stdio.h>
# Include <stdint.h>

uint8_t data [] =
int
main (int argc, char ** argv) {
  int i = 0;
  while (data [i]! = 0)
    data [i + +] ^ = 0x1f;
  uint32_t hash = 0xF748B421;
  for (i = 0; data [i]! = 0 + + i) {
    * hash = 0xD4C2087;
    hash ^ = data [i];
  }
  printf ("0x% X \ n", hash);
  return 0;
}
```

**402DCEh (cleanup) cleans up if something goes wrong.**

We go out of office and if all went well we display the PID of stage 2 in 401362h if we display "FAILED" in 40134Eh.