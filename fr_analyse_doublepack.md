# DoublePack, analyse d'un packer #



## Introduction ##
Durant plusieurs analyses nous sommes tombés sur un packer qui revenait assez souvent. Le packer est polymorphe c'est-à-dire que pour chaque binaire le code n'est pas exactement le même, mais l'esprit oui. Nous allons vous décrire comment depacker ces binaires à la main, puis comment nous avons analysé le code pour écrire un unpacker.

Nous travaillerons sur le fichier :

md5 : abc113dcabb074229f7f5b74a6dbc178

## Outils ##
  * Un débugueur pour l'analyse dynamique (dans notre cas [OllyDbg](http://www.ollydbg.de/))
  * [LordPE](http://www.woodmann.com/collaborative/tools/index.php/LordPE) afin de dumper une page mémoire
  * [IDA 5.0 free](http://www.hex-rays.com/products/ida/support/download_freeware.shtml) Les idb des fichiers analysés sont fournis ([abc113dcabb074229f7f5b74a6dbc178.idb](http://code.google.com/p/malware-lu/source/browse/doublepack/idb/abc113dcabb074229f7f5b74a6dbc178.idb) et [stage2.idb](http://code.google.com/p/malware-lu/source/browse/facebookspreader/idb/abc113dcabb074229f7f5b74a6dbc178.stage2.idb)). Dans ce qui suit, par convention, on nommera les fonctions par leur adresse virtuelle suivi entre parenthèses du nom donné dans l'idb. Example: DEADBEEFh (viandemorte).

## Unpack manuel ##

Commençons par regarder avec IDA le binaire à la recherche d'un call/jmp eax. La fonction 0041BC50h (start) parait intéressante, nous trouvons 2 boucles et elle termine par un jmp eax.

![http://malware-lu.googlecode.com/git/doublepack/img/ida-jmp-eax.png](http://malware-lu.googlecode.com/git/doublepack/img/ida-jmp-eax.png)

Nous n'allons pas creuser plus loin, pour le moment le but et de depacker.

Prenons notre débugueur favori et définissons un breakpoint sur 0041BFEFh (start+39Fh) soit le jmp eax.

Nous nous trouvons alors dans le contexte suivant avec un jmp 003C5350h

![http://malware-lu.googlecode.com/git/doublepack/img/olly-jmp-eax.png](http://malware-lu.googlecode.com/git/doublepack/img/olly-jmp-eax.png)

Regardons la memory map

![http://malware-lu.googlecode.com/git/doublepack/img/olly-memory-map.png](http://malware-lu.googlecode.com/git/doublepack/img/olly-memory-map.png)

Le code se situe donc sur le heap dans la page 003B0000h de taille 00017000h qui possède les flags RWE. On peut donc très bien exécuter du code dedans.

La technique classique de dump du process puis le fix des IAT n'est pas possibles dans ce cas là, car cela se passe sur une page mémoire allouée (heap).

Nous pensons que le binaire au complet se trouve dans la page mémoire ou dans une de ses voisines (003A0000h et 003B0000h). Effectuons une recherche sur MZ dans les différentes pages rien qui ressemble à un vrai PE n'est visible.

Maintenant, nous pouvons supposer que le code dans la page 003B0000h est :
  * cas 1 : le binaire packer chargé en mémoire sans le PE, là solution se trouve alors avant le jmp
  * cas 2 : on jmp vers une stage 2 du packer

Afin de prévoir l'analyse statique future, nous "dumpons" la page mémoire.

Pour cela nous utiliserons OllyDbg, à partir de la fenêtre Memory Map en double cliquant sur le page. Une nouvelle fenêtre apparaît clique droit, backup, save to files.

![http://malware-lu.googlecode.com/git/doublepack/img/olly-dmp-page.png](http://malware-lu.googlecode.com/git/doublepack/img/olly-dmp-page.png)

Ouvrons là avec IDA, la page n'ayant pas de PE qui définit la base adresse. Nous devons spécifier le champ loading offset qui correspond à l'adresse de base de notre dump dans ce cas 003B0000h.

![http://malware-lu.googlecode.com/git/doublepack/img/ida-loading-offset.png](http://malware-lu.googlecode.com/git/doublepack/img/ida-loading-offset.png)

Localisons ensuite le point d'entrée 003C5350h (la où le jmp point) puis créons une fonction à cet endroit que nous nommerons start

![http://malware-lu.googlecode.com/git/doublepack/img/ida-stage2-start.png](http://malware-lu.googlecode.com/git/doublepack/img/ida-stage2-start.png)

Cette idb nous sera utile pour la suite.

Nous pensons être dans le cas 2. Regardons alors le code exécuté en déroulant le programme pas à pas.

Nous voyons qu'il appel les fonctions suivantes :
```c

getModuleHandle(NULL) // retourne l'adresses du PE header du programme
getModuleHandle("kernel32")
HANDLE heap = getProcessHeap() // retourne l'adresses du heap du programme
LPVOID data = HeapAlloc(heap,  0, 0x14400) // Alloue 0x14400 à l'address heap
```

Note dans notre cas "data" se situe à l'adresse 00153A90h

Cela nous conforte dans l'idée d'avoir à faire à une stage 2 d'un packer particulièrement l'allocation de 14400h bytes sur le heap qui est plutôt rare, pour un programme surtout dès le début de son exécution.

Continuons d'avancer pour arriver sur une boucle while dont la condition est comparable à i < 0x14400. Nous retrouvons la taille de la valeur allouée ce qui pourrait correspondre à la taille du binaire.

Regardons les données à 00153A90h (data) puis avançons dans la boucle jusqu'a voir des données écrites dans data.

![http://malware-lu.googlecode.com/git/doublepack/img/olly-00153A90-data.png](http://malware-lu.googlecode.com/git/doublepack/img/olly-00153A90-data.png)

Nous notons que cela ressemble étrangement à un début de PE offusqué (ci-dessous un hexdump d'un PE normal)

![http://malware-lu.googlecode.com/git/doublepack/img/hd-pe-legit.png](http://malware-lu.googlecode.com/git/doublepack/img/hd-pe-legit.png)

Passons cette boucle pour arriver directement sur une 2e. Nous supposons qu'elle va désoffusquer le binaire. Continuons de surveiller les données à 00153A90h (data) et avançons pas à pas jusqu'à voir quelque chose changer dans 00153A90h (data)

![http://malware-lu.googlecode.com/git/doublepack/img/olly-stage2-loop2.png](http://malware-lu.googlecode.com/git/doublepack/img/olly-stage2-loop2.png)

Le 1er byte passe alors à MZ, il nous reste à passer cette boucle pour avoir le binaire complet en mémoire.

![http://malware-lu.googlecode.com/git/doublepack/img/olly-stage2-loop2-out.png](http://malware-lu.googlecode.com/git/doublepack/img/olly-stage2-loop2-out.png)


Nous "dumpons" la mémoire à 00153A90h sur 14400h. Pour cela, nous utiliserons LordPE et la fonction DumpPartial

![http://malware-lu.googlecode.com/git/doublepack/img/img-lordpe-dump-partial.png](http://malware-lu.googlecode.com/git/doublepack/img/img-lordpe-dump-partial.png)


## Analyse du packer ##
Dans cette partie, nous utiliserons uniquement IDA et les fichiers idb suivant :
  * [abc113dcabb074229f7f5b74a6dbc178.idb](http://code.google.com/p/malware-lu/source/browse/doublepack/idb/abc113dcabb074229f7f5b74a6dbc178.idb)
  * [stage2.idb](http://code.google.com/p/malware-lu/source/browse/facebookspreader/idb/abc113dcabb074229f7f5b74a6dbc178.stage2.idb)

### Stage1 ###

1ere chose que nous remarquons le code possède du garbage c'est à dire des appels à des fonctions qui n'ont pas d'intérêt dans l'exécution du programme surement dans le but de tromper lors d'une analyse rapide.

#### Initialisation ####

Le code devient intéressant à partir de 0041BD14h (loc\_41BD14)

![http://malware-lu.googlecode.com/git/doublepack/img/ida-loc_41BD14-init.png](http://malware-lu.googlecode.com/git/doublepack/img/ida-loc_41BD14-init.png)

Action :
  * Initialise des variables (les variables inutilisées sont appelées garbageX).
  * Appel 0041BA10h (setStage2DataPointer) qui s'occupe de récupérer l'adresse des data de la stage2.
  * Récupère la taille finale de la stage qui s'obtient ainsi (en suivant la logique définie ci-dessous)

```
stage2DataSize = *(DWORD*)(Stage2Data - 4)
```

  * Alloue à l'aide de VirtualAlloc une page de la taille de Stage2DataSize avec les flags RWE.

Pour simplifier, nous pouvons représenter les données utilisées dans le binaire de cette façon

```
-------------------------------------------
DWORD Stage2DataSize
-------------------------------------------
unsigned char Stage2Data[Stage2DataSize]
-------------------------------------------
Junk
-------------------------------------------
DWORD Stage2TableSize
-------------------------------------------
unsigned char Stage2Table[Stage2TableSize]
-------------------------------------------
Junk
-------------------------------------------
```

Nous verrons juste après que cela n'est pas exactement vrai.

#### Reconstruction des données de la stage2 ####

![http://malware-lu.googlecode.com/git/doublepack/img/ida-reconstruct-loop1.png](http://malware-lu.googlecode.com/git/doublepack/img/ida-reconstruct-loop1.png)

1ere boucle qui s'occupe de reconstruire les données dans la mémoire allouée. Stage2Data est enfaite construite de cette façon :

```
|DATA|JUNK|DATA|JUNK|...
```

  * DATA`[`chunk`]`, contient les vraies données
  * JUNK`[`junk`]`, contient des données inutiles

Avec ces informations, nous pouvons corriger le tableau précédent :

```
-------------------------------------------------------------------------
DWORD Stage2DataSize
-------------------------------------------------------------------------
unsigned char Stage2Data[Stage2DataSize + (Stage2DataSize/chunk)*junk]
-------------------------------------------------------------------------
DWORD Stage2TableSize
-------------------------------------------------------------------------
unsigned char Stage2Table[Stage2TableSize + (Stage2TableSize/chunk)*junk]
-------------------------------------------------------------------------
```

La boucle peut être écrite en C de cette façon (on gardera ici le nommage de l'idb) :
```c

uint32_t m, restant;
uint32_t i = 0, y = 0;

restant = size;
while( x < size ){
m = min(chunk, restant);
memcpy(pMemStage2Data+x, pStage2+y, s);
x += chunk;
y += chunk + junk;
restant -= s;
}
```


#### Boucle de décodage ####

Appelle de 0041BB60h (decode) afin de décoder les données

![http://malware-lu.googlecode.com/git/doublepack/img/ida-call-decode1.png](http://malware-lu.googlecode.com/git/doublepack/img/ida-call-decode1.png)

La fonction 0041BB60 (decode)

![http://malware-lu.googlecode.com/git/doublepack/img/ida-decode.png](http://malware-lu.googlecode.com/git/doublepack/img/ida-decode.png)

Nous remarquons une valeur en dure pour décoder, dans notre cas 39h et un CreateFile inutile.

Nous pouvons la réécrire de cette façon en C :
```c

uint32_t decode(uint8_t *data, uint32_t size){
uint32_t i;
for (i=0; i < size; i+=4){
*(uint32_t*)(data+i) += i;
*(uint32_t*)(data+i) ^= (i + 0x39);
}
return 0x42; // inutile aussi
}
```

#### Le "jmp" ####

Le même processus pour récupérer dans pMemStage2Table les données de Stage2PatchTable est appliqué (reconstruction puis décodage).

Sautons donc directement à 0041BF5Ah (loc\_41BF5A) après le 2e call decode à la position 0041BF6Dh (start+31D).

![http://malware-lu.googlecode.com/git/doublepack/img/ida-loc_41BF5A.png](http://malware-lu.googlecode.com/git/doublepack/img/ida-loc_41BF5A.png)

Action :
  * Allouer une nouvelle page mémoire avec une taille en dure de 0x17000
  * Copier en se décalant de 200h pMemStage2Data.
  * Calculer delta; le décalage à appliquer à tout les références dans le code afin d'avoir un code fonctionnel par la suite.

```
delta = pAdrAllouer - 0x400000 // 0x400000 est la base adresse par default d'un programme
```

  * Appel la fonction rebase qui s'occupe de fixer les adresses avec l'aide du delta et de pMemStage2Table (la table de réalocation).

```
void rebase(uint8_t *tpatch, uint8_t *dst, uint32_t delta)
```

Une fois le page mémoire prête, il calcul le point d'entré avec une valeur en dure 15350h puis jmp dessus.

pMemStage2 peut être représenté de cette façon :

```
-------------------------------
Point d'entré à 15350h
-------------------------------
200h, Vide
-------------------------------
15500h, Stage2
-------------------------------
1E00h, Vide
-------------------------------
```

Avec la base
```
-------------------------------
Point d'entré à 3C5350h
-------------------------------
003B0000h - 003B0200h | Vide
-------------------------------
003B0200h - 003C5700h | Stage2
-------------------------------
003C5700h - 003C5701h | Vide
-------------------------------
```


### Stage2 ###

TODO (même principe que la stage1 voir [stage2.idb](http://code.google.com/p/malware-lu/source/browse/facebookspreader/idb/abc113dcabb074229f7f5b74a6dbc178.stage2.idb))
<a href='Hidden comment: 
La stage2 possède la même logique que la 1ere sauf que cette fois elle decoderra le binaire puis l"executera.

http://malware-lu.googlecode.com/git/doublepack/img/ida-stage2_start.png

Action:
* Recupère l"offset du binaire
* Recupère la taille du binaire
* Alloue de la mémoire sur le heap avec HeapAlloc.
* Arrive sur la boucle de reconstruction

http://malware-lu.googlecode.com/git/doublepack/img/ida-stage2_reconstruction.png

Action:
* Comme précédement reconstruit le binaire dans la mémoire alloué avec HeapAlloc en fonction de junk et chunk (dans ce cas là réspectivement 1 et 78).
* Ensuite boucle de décodage en inline

http://malware-lu.googlecode.com/git/doublepack/img/ida-stage2_decodage.png


Action:
* Decode les données avec comme valeur en dure 0x3e9

La fin ne serra pas détaillé mais nous avons à faire un alignement dans une nouvelle page mémoire
'></a>


## Création d'un unpacker ##

[unpacker.c](http://code.google.com/p/malware-lu/source/browse/doublepack/code/unpacker.c)

TODO

## Hash md5 ##
Voici quelque hash md5 de fichier packet avec ce packer :
```
abc113dcabb074229f7f5b74a6dbc178
9958bac6beca4faf35a8316542b91107
eb3ef30274d4c79a70262596525c31be
abc113dcabb074229f7f5b74a6dbc178
ec919d79a287416a61d0bb0585b2a430
ed838f0def4c9cf70d3a06b9fb5ed934
ef7c727ffecfc8ba34b55f04e1f326ce 
f5291d32de89f7c060564447a221f388
f5e3c1b7edaaf55147a8010e291dd671
```