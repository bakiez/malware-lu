# Un peu d'analyse statique #


## Introduction ##

Cette article présente une analyse d'un des binaires de Duqu; le key logger, et plus particulièrement l'analyse du stage 1 qui déchiffre et lance la charge. L'analyse des stage suivant est présenté dans [fr\_analyse\_statique\_duqu\_stage\_2.wiki stage\_2].
Le but n'est pas de proposer encore une nouvelle analyse de ce malware: d'autres l'ont fait bien mieux que nous et d'une manière bien plus complète.
D'ailleurs nous ne disposons pas de tous les binaire ce qui nous contraint à une vision partielle.
L'objectif est plutôt de présenter quelques techniques d'analyses statiques que nous utilisons régulièrement en réponses aux incidents.

## Outils ##
  * [Metasm](http://code.google.com/p/metasm/) principalement utilisé dans [ripper.rb](http://code.google.com/p/malware-lu/source/browse/duqu/ripper.rb).
  * [IDA 5.0 free](http://www.hex-rays.com/products/ida/support/download_freeware.shtml) Les idb des fichier analysé sont fourni ([duqu.idb](http://code.google.com/p/malware-lu/source/browse/duqu/duqu.idb) et [duqu.0x5098.idb](http://code.google.com/p/malware-lu/source/browse/duqu/duqu.0x5098.idb)). Dans ce qui suit, par convention, on nommera les fonctions par leur addresse virtuelle suivi entre parenthèse du nom donné dans l'idb. Example: DEADBEEFh (viandemorte).


## Etude de cas ##

Ce document propose une analyse d'un examplaire de Duqu obtenu sur [Offensive computing](http://www.offensivecomputing.net/) et inclu dans le repository: [duqu.zip](http://www.malware.lu/_download.php?md5=9749d38ae9b9ddd81b50aad679ee87ec) (password: infected).
```
$ md5sum duqu
9749d38ae9b9ddd81b50aad679ee87ec  duqu
$ objdump -p duqu | head -n 9

duqu:     file format pei-i386

Characteristics 0x102
	executable
	32 bit words

Time/Date		Wed Jun  1 04:25:18 2011
Magic			010b	(PE32)
```

# L'initialisation #

Le code d'initialisatien n'est pas fort intéressant:
  * 4013AEh (parseargs) : parsing de la ligne le commande
    * Verbosité.
      * Action (/delme /quit /restart).
      * Noms de fichier peuvent être fournis pour les entrées/sorties. Les valeurs par default sont les suivantes.
        * Le .rcrs pour l'entrée cf 401508h (loadinput),
        * Fichier temporaire pour la sortie cf 4010BCh (loadoutput).
  * 401160h (setupIO) : construit un tableau de chaines (table offset/length + section data) contenant les noms de l'entrée, output du module courant.
  * On appelle 401269h (main) où :
    * 4015B5h (loadresource) récupère une ressoure dans le .rsrc,
    * 4012BBh (main) cette ressource passe en accès PAGE\_WRITECOPY.
    * On appelle 401676h (main`_`0) avec comme argument
      * arg\_0 (wkmem): l'adresse de la ressource + 4kB.
      * arg\_4 (wkmemsize): la taille de la ressource - 4kB.
      * arg\_8 (action): l'action parsé.
      * arg\_C (IOdesc): la description des IO.
      * arg\_10 (nbargs): le nombre d'arguments parsés de la ligne de commande.
      * arg\_14 (handle\_out): un pointeur sur un handle qui sera fermé si en revenant de l'appel.
      * arg\_18 (defaultexe): la chaine "winlogon.exe", nota si main échou on le rappelle avec "svchost.exe".

La seule fonction un peu intéressante est 4010BCh (loadoutput), on y voit le préfixe du fichier temporaire:_~DQ_.
Ceci pourrai peut être expliquer comment a été choisi le nom de ce malware… et non ce n'était pas seulement pour faire rire les frenchies avec des allusions obsaines !

# Obfuscation des API call #

Une fois dans 401676h (main`_`0) la première étape est 4024C0h (selectexe) dont l'objet est de sélectionner le chemin d'un executable en fonction des processus en mémoire. Puis 401B16h (main`_`1) est appelée avec les mêmes arguments que main\_0 où arg\_18 (defaultexe) a été sbstitué chemin complet vers l'executable choisi (cf plus bas)

Tout cela n'est pas très folichon. Un aspect ratrappe le reste: l'obfucation des API call dans 4023F8h (lookforaproc). On a une variante de getfunctionbyname : au lieu de donner les noms de la library et de l'API, on fournit une chaine xorée et un hash.
  * 401B96h (unxor) xor la chaine pour obtenir le nom de la library.
  * 401BCEh (getfunbyhash`_`0) hash une à une tous les nom d'API de la library jusqu'à trouver le bon.

Comme on est faignant on ne va pas essayer de comprendre cela dans le détail, on va simplement ripper le code du sample et lui laisser faire le boulot.
Pour cela nous allons utiliser [Metasm](http://code.google.com/p/metasm/) et lui demander d'extraire les fonctions qui nous intéressent.
La magie est opérée par [ripper.rb](http://code.google.com/p/malware-lu/source/browse/duqu/ripper.rb) pour désassembler le code, l'encapsuler dans une fonction C et exécuter le résultat.

## Déchiffrement des strings ##

Pour le déchiffrement des strings cela donne le code suivant. _Nota :_ on en profite pour déchiffrer toutes les strings et pas seulement celles des noms de library.
```
malware-lu $ cat decryptstrings.rb
# include the magic ripper
require "ripper.rb"
# get a disassembler on first arg
disasm = AutoExe.decode_file(ARGV[0]).init_disassembler
# Rip function at 0x401B96 with signature int decrypt(char* in, char* in);
specs = [Spec.new(0x401B96, "int decrypt(char* in, char* out);")]
worker = Ripper.new(disasm, specs)
# For all the encrypted strings offset
for a in [0x384C, 0x3870, 0x388C, 0x38A0, 0x38C0, 0x38D0, 0x3914, 0x3930, 0x39A0, 0x3A10, 0x3A80, 0x3AF0, 0x3B60, 0x3BD0, 0x3C20, 0x3C70, 0x3C88, 0x3DA0, 0x3DD0, 0x3E00, 0x3E60, 0x3E88, 0x3EB0, 0x3EE8, 0x3F10, 0x3F64, 0x3F8C, 0x3FC4, 0x3FD8, 0x4058, 0x4098, 0x40B0, 0x4108, 0x4130, 0x4158, 0x4170, 0x41EC, 0x4200, 0x4230, 0x4270, 0x42B8, 0x42FC, 0x4310, 0x4350, 0x4398, 0x43F4, 0x44FC, 0x4508, 0x4524]
  # Read the encrypted string
  srcFile = File.open(ARGV[0], 'r')
  srcFile.seek(a, IO::SEEK_SET)
  # never longer than 0x80
  src = srcFile.sysread(0x80)
  # Allocate output
  dst = "\x00" * (src.length)
  # Decryt and output
  worker.runner.decrypt(src, dst)
  puts "#{a.to_s(16)}: #{dst}"
end
malware-lu $ ruby decryptstrings.rb duqu
384c: ResumeThread
3870: kernel32.dll
388c: ntdll.dll
38a0: advapi32.dll
38c0: 
38d0: %A\Kaspersky Lab\AVP%v\Bases\*.*c
3914: Mcshield.exe
3930: SOFTWARE\KasperskyLab\protected\AVP80\environment
39a0: SOFTWARE\KasperskyLab\protected\AVP11\environment
3a10: SOFTWARE\KasperskyLab\protected\AVP10\environment
3a80: SOFTWARE\KasperskyLab\protected\AVP9\environment
3af0: SOFTWARE\KasperskyLab\protected\AVP8\environment
3b60: SOFTWARE\KasperskyLab\protected\AVP7\environment
3bd0: SOFTWARE\kasperskylab\avp7\environment
3c20: SOFTWARE\kasperskylab\avp6\environment
3c70: ProductRoot
3c88: avp.exe
3da0: %C\McAfee\Engine\*.dat
3dd0: SOFTWARE\McAfee\VSCore
3e00: szInstallDir32
3e60: avguard.exe
3e88: bdagent.exe
3eb0: UmxCfg.exe
3ee8: fsdfwd.exe
3f10: %C\Symantec Shared\VirusDefs\binhub\*.dat
3f64: rtvscan.exe
3f8c: ccSvcHst.exe
3fc4: ekrn.exe
3fd8: %A\ESET\ESET Smart Security\Updfiles\*.nup
4058: SOFTWARE\TrendMicro\NSC\TmProxy
4098: InstallPath
40b0: tmproxy.exe
4108: SOFTWARE\Rising\RIS
4130: SOFTWARE\Rising\RAV
4158: InstallPath
4170: RavMonD.exe
41ec: 360rp.exe
4200: 360sd.exe
4230: %SystemRoot%\system32\lsass.exe
4270: %SystemRoot%\system32\winlogon.exe
42b8: %SystemRoot%\system32\svchost.exe
42fc: psapi.dll
4310: %SystemRoot%\syswow64\lsass.exe
4350: %SystemRoot%\syswow64\winlogon.exee
4398: %SystemRoot%\syswow64\svchost.exe
43f4: version.dll
44fc: CODE
4508: advapi32.dll
4524: userenv.dll
```

## Récupération des API calls ##

Duqu travaille sur les librairies loadées en mémoire, ainsi on a besoin des mapping de nos library favorite. Comme ce n'est pas un tutorial sur le [loading PE](http://msdn.microsoft.com/en-us/magazine/cc301805.aspx) tout le matos se trouve sur [pedump](http://code.google.com/p/malware-lu/source/browse/duqu/#git%2Fpedump).
```
malware-lu $ cd pedump/
pedump $ make
gcc -o pedump pedump.c pefile.c -I.
pedump $ cd ..
malware-lu $ echo Please get those dll: $(ls *dll)
Please get those dll: advapi32.dll kernel32.dll ntdll.dll psapi.dll userenv.dll version.dll
malware-lu $ for i in $(ls *dll); do pedump/pedump $i > $i.mapped; done
```

On passe au rip… même principe que pour les strings chiffrées.
```
malware-lu $ cat getfunbyhash.rb 
# include the magic ripper
require "ripper.rb"
# get a disassembler on first arg
disasm = AutoExe.decode_file(ARGV[0]).init_disassembler
# Rip function at 0x401BCE with signature int decrypt(char* in, char* in);
specs = [Spec.new(0x401BCE,"unsigned int getfun(char* in, unsigned int hash);")]
worker = Ripper.new(disasm, specs)
# Decode exports
pe = Metasm::PE.decode_file_header(ARGV[1])
pe.decode_exports
# for each provided hash
for hash in ARGV[3..ARGV.length]
  # Get the mapped dll
  srcFile = File.open(ARGV[2], 'r')
  src = srcFile.read()
  # Get the rva from duqu code
  rva = worker.runner.getfun(worker.runner.str_ptr(src), hash.hex) - worker.runner.str_ptr(src)
  # Search for the name in exports 
  pe.export.exports.each { |exp|
    if exp.target_rva == rva
      puts "#{hash}:#{exp.name}"
    end
  }
end
malware-lu $ cat export.sh 
#kernel32.dll
echo kernel32.dll
ruby getfunbyhash.rb duqu kernel32.dll kernel32.dll.mapped 0x88444BE9 0x92D66FBA 0xD1A588DB 0xFCAA0AB8 0xAE75A8DB 0xCF5350C5 0xDCAA4C9F 0x4BBFABB8 0xA668559E 0x4761BB27 0xD3E360E9 0x6B3749B3 0xD830E518 0x78C93963 0xD83E926D 0x19BD1298 0x6F8A172D 0xBF464446 0xAE16A0D4 0x3242AC18 0x479DE84E 0xB67F8157
#psapi.dll
echo psapi.dll
ruby getfunbyhash.rb duqu psapi.dll psapi.dll.mapped 0xBCC7C0DA 
#advapi32.dll
echo advapi32.dll
ruby getfunbyhash.rb duqu advapi32.dll advapi32.dll.mapped 0x6012A950 0xC6151DC4 0xF03A2554 0x9C6E14F8 0x702B6244 0x2EDB7947 0x557DBBB6 0xE763A4A3
#version.dll
echo version.dll
ruby getfunbyhash.rb duqu version.dll version.dll.mapped 0xD4DE04DA 0xCEF01246
#userenv.dll
echo userenv.dll
ruby getfunbyhash.rb duqu userenv.dll userenv.dll.mapped 0x3E692063 0xAFF5F91F
#ntdll.dll
echo ntdll.dll
ruby getfunbyhash.rb duqu ntdll.dll ntdll.dll.mapped 0x40C4EC59 0x4FE2B7A2  0x5FC5AD65 0x1D127D2F 0x468B8A32 0xDB8CE88C 0x4143C970
```

Et voici la table de correspondance. Nota: comme pour les strings on en profite pour traduire tous les hash rencontrés dans le code.
```
malware-lu $ bash export.sh
kernel32.dll
0x88444BE9:CreateToolhelp32Snapshot
0x92D66FBA:Process32FirstW
0xD1A588DB:Process32NextW
0xFCAA0AB8:OpenProcess
0xAE75A8DB:CreateProcessW
0xCF5350C5:GetNativeSystemInfo
0xDCAA4C9F:IsWow64Process
0x4BBFABB8:lstrcmpiW
0xA668559E:VirtualQuery
0x4761BB27:VirtualProtect
0xD3E360E9:GetProcAddress
0x6B3749B3:MapViewOfFile
0xD830E518:UnmapViewOfFile
0x78C93963:FlushInstructionCache
0xD83E926D:LoadLibraryW
0x19BD1298:FreeLibrary
0x6F8A172D:CreateThread
0xBF464446:WaitForSingleObject
0xAE16A0D4:GetExitCodeThread
0x3242AC18:GetSystemDirectoryW
0x479DE84E:CreateFileW
0xB67F8157:CreateRemoteThread
psapi.dll
0xBCC7C0DA:GetModuleFileNameExW
advapi32.dll
0x6012A950:RegOpenKeyExW
0xC6151DC4:RegQueryValueExW
0xF03A2554:RegCloseKey
0x9C6E14F8:CreateProcessAsUserW
0x702B6244:DuplicateTokenEx
0x2EDB7947:OpenProcessToken
0x557DBBB6:LookupPrivilegeValueW
0xE763A4A3:AdjustTokenPrivileges
version.dll
0xD4DE04DA:GetFileVersionInfoW
0xCEF01246:VerQueryValueW
userenv.dll
0x3E692063:CreateEnvironmentBlock
0xAFF5F91F:DestroyEnvironmentBlock
ntdll.dll
0x40C4EC59:NtQueryInformationProcess
0x40C4EC59:ZwQueryInformationProcess
0x5FC5AD65:NtCreateSection
0x5FC5AD65:ZwCreateSection
0x1D127D2F:NtMapViewOfSection
0x1D127D2F:ZwMapViewOfSection
0x468B8A32:NtUnmapViewOfSection
0x468B8A32:ZwUnmapViewOfSection
0xDB8CE88C:NtClose
0xDB8CE88C:ZwClose
```

# Selection de la cible #
Le code est maintenant désoffusqué. Nous pouvons continuer le reverse de 401B16h (main`_`1) et 4024C0h (select exe).
  * 40F3F8h (lookforaproc) est une simple boucle sur les process applicant 402397h (gettargetparam). On break si cette fonction réussi.
  * 402397h (gettargetpath) vérifie si le nom du process courrant est dans le tableau 40703Ch (proctable) et si c'est le cas applique 4022E2h (getpath). Les nom ciblé sont les suivant:
    * avp.exe (Kaspersky)
    * Mcshield.exe (McAfee)
    * avguard.exe (Avira)
    * bdagent.exe (BitDefender)
    * umxCfg.exe (CA eTrust)
    * fsdfwd.exe (Fsecure)
    * rtvscan.exe (Symantec)
    * ccSvcHst.exe (Symantec)
    * ekrn.exe (ESET)
    * tmproxy.exe (PC-cillin)
    * RavMonD.exe (Rising antivirus)
> Depuis 40703Ch (proctable) on obtient une structure de la forme suivante (on aura pris soin de la définir dans ida):
```
00000000 proctable_entry struc; (sizeof=0xC)
00000000 procname        dd ?
00000004 dwProductVersionLS dd ?
00000008 regkey          dd ?
0000000C proctable_entry ends
```
  * 4022E2h (getpath) selectionne un path obtenu depuis une clé registre sélectionnée en fonction de la version du fichier associé au proccess ciblé.
    * 402242h (regkeywrtprodvs)
      * 4020EBh (getproductversion) ouvre le processus ciblé et récupére le nom de fichier associé.
      * Si OpenProcess échoue 401F7Dh (getpathviacomm) essaie de faire la même chose via un interface COM. Une fois le path obtenu, on récupére dwProductVersionLS via GetFileVersionInfoW et VerQueryValueW.
      * Le champ proctable\_entry.dwProductVersionLS pointe sur un tableau de versions. On boucle jusqu'à trouver la version qui match. On obtient alors un tableau de clé de registre spécifiée par la structure suivante.
```
00000000 regspec         struc ; (sizeof=0x14)
00000000 key             dd ?
00000004 subkey          dd ?
00000008 value_path      dd ?
0000000C field_C         dd ?
00000010 dfltregkey      dd ?
00000014 regspec         ends
```
      * J'avoue être dubitatif sur les offsets 0xC et 0x10 et vue qu'en 40209B l'incrément est de 0x18 il doit y avoir encore un champ. Il faudrait regarder le .data pour vérifier… de toutes façons on s'en fout.
    * 402079h(getpathfromreg) boucle sur le tableau des clés de registre appliquant 401D5Ch (getvalue) qui vérifie que la path récupérée pointe sur un fichier existant.
  * Si 40F3F8h (lookforaproc) n'a pas trouvé de path valide  un path est choisi dans en fonction du code de retour l'un des tableaux 407068h (winprocpathtable\_0) (lsass authorisé) ou 407080h (winprocpathtable) (lsass non authorisé). Les path par défault sont:
    * %SystemRoot%\system32\lsass.exe
    * %SystemRoot%\system32\winlogon
    * %SystemRoot%\system32\svchost
  * On appelle 401B16h (main`_`1) qui appelle 4019DFh (main`_`2) avec deux arguments.
    * arg\_0 (exedesc) : La structure suivante
```
00000000 exedesc         struc ; (sizeof=0x30)
00000000 targetpath      dd ?
00000004 machinetype     dd ?
00000008 wkmem           dd ?
0000000C nargs           dd ?
00000010 field_10        dd ?
00000014 wkmemsize       dd ?
00000018 action          dd ?
0000001C IOdesc          dd ?
00000020 field_20        dd ?
00000024 token           dd ?
00000028 field_28        dd ?
0000002C startupinfo     dd ?
00000030 exedesc         ends
```
    * arg\_4 (processinfohdl) : Un pointer qui pointera vers le handle d'un LPPROCESS\_INFORMATION.

# Dechiffrement du stage 2 #

4019DFh (main`_`2) commence par déchiffrer le stage 1 dans 4033C4h (decryptstage2). On y appelle 403315h (getmachine) qui récupère le _machine type_ de l'executable ciblé plus haut dans 401B16h (main`_`1). On a alors deux cas :
  * **14Ch (i`[`345`]`86) :** 4035F0h (getstage2) récupère le stage 2 chiffré à l'addresse 407098h (stage2) correspond à l'offset 0x5098 du fichier. La longueur du stage 2 est de 310Ch octets.
  * **8664h (amd64) :** Le code appelle 4035F0h (pass), une fonction vide qui retourne un NULL. Apparamment le support 64bit est prévu mais pas implémenté ou stripé.

Les deux branches conduisent vers le déchiffrement en 403268h (decrypt). Celle-ci calcule un nom d'un mutex depuis le PID et le prend. Ce comportement est assez étrange car le code n'est pas multithreadé. Ce code doit être générique et peut être aussi utilisé dans d'autres composants de Duqu.
```
char* todecrypt; // = 407098h (stage2) dans notre cas
char name[0x3C];
int i = 0;
int pid = GetCurrentProcessId() ^ todecrypt;
for (; pid != 0; pid /= 11)
    name[2 * (i++)] = (pid & 7) + '0';
name[2 * i] = 0;
```

Puis on test test si 407098h (stage2) est chiffré en comparant les deux premiers octets avec "MZ". 40350Eh (decrypt`_`0) s'occupe du déchiffrement: une sorte de xor sur graine. Encore une fois on est faignant donc on se fiche de l'algo exact. Comme précédemment, on va ripper 40350Eh (decrypt`_`0) afin d'obtenir le stage 2 en clair.
```
$ cat decryptstage2.rb 
# include the magic ripper
require "ripper.rb"
# get a disassembler on first arq
disasm = AutoExe.decode_file(ARGV[0]).init_disassembler
# Rip function at 0x40350E with signature int decrypt(char* text, int length, int* key);
specs = [Spec.new(0x40350E, "int decrypt(char* text, int length, int* key);")]
# Actually rip it
worker = Ripper.new(disasm, specs)
# Setup the arguments 0x5098 is the file offset corresponding to 407098h
length = 0x310C
offset = 0x5098
srcFile = File.open(ARGV[0], 'r')
srcFile.seek(offset, IO::SEEK_SET)
src = srcFile.sysread(length)
a = "\x00" * 4
# Launch the ripped function
worker.runner.decrypt(src, length, a)
# Output text in clear
File.open(ARGV[0] + ".0x#{offset.to_s(16)}.decrypted", 'w+'){|fd| fd << src}
$ ruby decryptstage2.rb duqu
$ file duqu.0x5098.decrypted 
duqu.0x5098.decrypted: PE32 executable for MS Windows (GUI) Intel 80386 32-bit
```

Aprés avoir relaché le mutex on en a fini avec le déchiffrement du stage 2 et on retourne dans 4019DFh (main`_`2).

# Lancement du stage 2 #

Une fois le stage 2 déchiffré, 4019DFh (main`_`2) appelle 40266Fh (checkPE) qui vérifie que le déchiffrement s'est bien passé en vérifiant les headers "MZ", "PE" et la taille de l'optional header. Nota1 : le stage 2 est un PE .Nota2 : les deux cas 32bit et 64bits sont acceptés. 40266Fh (checkPE) rend aussi un pointeur sur le PE header du stage 2.

On passe ensuite à la très rébarbative création d'un console avec 402F82h (createconsole`_`0). Dans les grandes lignes :
  * Version simple : on a pas fourni de token et on appelle 402DF0h (do\_CreateProcess) qui nous fait un simple CreateProcess (CREATE\_NO\_WINDOW | CREATE\_UNICODE\_ENVIRONMENT | CREATE\_SUSPENDED | DETACHED\_PROCESS) | CREATE\_NEW\_CONSOLE, la création de console est passé en argument : arg\_10 (createconsole).
  * Version longue : on a un token pour le nouveau process
    * Ajustement des privilèges du token courrant (SeTcbPrivilege, SeAssignPrimaryTokenPrivilege. SeIncreaseQuotaPrivilege, SeImpersonatePrivilege).
    * Duplication du token.
    * Récupération des variable d'environement de l'user cible.
    * Création du process (CREATE\_NO\_WINDOW | CREATE\_UNICODE\_ENVIRONMENT | CREATE\_SUSPENDED | DETACHED\_PROCESS) | CREATE\_NEW\_CONSOLE, la création de console est passé en argument : arg\_10 (createconsole).
    * On nétoie l'environement et la copie du token.

De retour dans 4019DFh (main`_`2) :
  * 401A54h, on récupère un pointeur sur le header PE de la ressource wkmem exedesc. Nota : cette resource était donc un PE… on avait pas pris la peine de regarder.
  * 401A6Eh, on vérifie que la cible de l'injection est bien un processus 32 bit.
  * 401A6Eh, on vérifie que le processus cible et wkmem ont le même machine type.
  * 402E99h (getprocinfo) récupère depuis l'arg\_4 (procinfohdl) de 4019DFh (main`_`2)
    * basic process information,
    * InheritedAddressSpace
    * entrypoint
  * 401AB3h (maprocmem) charge wkmem en mémoire.
  * 4025C0h (UnmapViewOfSection) est simplement un wrapper vers UnmapViewOfSection, ici on nétoie la view sur le processus cible mappée dans UnmapViewOfSection.
  * 40189Ah (mapstage2\_1) charge le stage 2 en mémoire et copie les ressources.
  * On lance le stage de grâce à un ResumeThread. Cet API call et offusqué d'une manière un peu différente. On fait toujour appel à 401BCEh (getfunbyhash\_0) mais ici le hash est calculé depuis la chaine 40534C (ResumeThread). Le code [decode.401D18.c](http://code.google.com/p/malware-lu/source/browse/duqu/decode.401D18.c) calcule ce hash.
```
#include <stdio.h>
#include <stdint.h>

uint8_t data[] = "\x4d\xb3\x7a\xb3\x6c\xb3\x6a\xb3\x72\xb3\x7a\xb3\x4b\xb3\x77\xb3\x6d\xb3\x7a\xb3\x7e\xb3\x7b\xb3\x1f";
int 
main (int argc, char** argv){
  int i = 0; 
  while (data[i] != 0)
    data[i++] ^= 0x1f;
  uint32_t hash = 0xF748B421;
  for (i = 0; data[i] != 0; ++i){
    hash *= 0xD4C2087;
    hash ^= data[i];
  }
  printf ("0x%X\n", hash);
  return 0;
}
```

**402DCEh (cleanup) fait le ménage si quelque chose se passe mal.**

On sort de fonction et si tous s'est bien passé on affiche le PID du stage 2 en 401362h sinon on affiche « FAILED » en 40134Eh.